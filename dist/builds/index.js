!function(){"use strict";function t(){M.pos.x=Math.cos(2*I)*E.distance,M.pos.z=Math.sin(2*I)*E.distance,M.pos.y=E.distance,b.pos.x=Math.cos(I+Math.PI)*E.distance,b.pos.z=Math.sin(I+Math.PI)*E.distance,b.pos.y=E.distance,M.matricesNeedUpdate=!0,b.matricesNeedUpdate=!0,A.render(N,M),B.render(N,b),T&&(I=(I+.02)%(2*Math.PI)),requestAnimationFrame(t)}var e;!function(t){t.sync=function(t){let e=new XMLHttpRequest;if(e.open("GET",t,!1),e.send(),4==e.readyState&&200==e.status)return e.responseText},t.async=function(t){return new Promise((e,i)=>{let r=new XMLHttpRequest;r.open("GET",t,!0),r.onload=function(t){4!=r.readyState||200!=r.status?i(r.status):e(r.responseText)},r.onerror=(t=>i(t)),r.send()})}}(e||(e={}));var i=e;class r{constructor(t){this.id=t,this.canvas=document.getElementById(t),this.canvas.width=this.canvas.clientWidth,this.canvas.height=this.canvas.clientHeight;let e=this.canvas.getContext("webgl");if(null==e)throw"WebGL not supported !";this.gl=e,this.gl.clearDepth(1),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.DEPTH_TEST),this.gl.clearColor(0,0,0,1),this.modes=[this.gl.TRIANGLES,this.gl.LINES,this.gl.POINTS],this.mode=0}setMode(t){this.mode=t%3}getModeIdx(){return this.mode}getMode(){return this.modes[this.mode]}render(t,e){this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),t.render(this,e)}}class s{constructor(){this.meshes=[],this.pointLights=[],this.spotLights=[],this.ambientLight={color:BABYLON.Vector4.Zero()}}addMesh(t){return this.meshes.push(t),t}getMesh(t){return this.meshes[t]}removeMesh(t){return this.meshes.splice(t,1)[0]}addPointLight(t,e=new BABYLON.Vector4(1,1,1,1),i=300){let r={pos:new BABYLON.Vector3(t.x,t.y,t.z),color:e,intensity:i};return this.pointLights.push(r),r}getPointLight(t){return this.pointLights[t]}removePointLight(t){return this.pointLights.splice(t,1)[0]}addSpotLight(t,e,i,r=new BABYLON.Vector4(1,1,1,1),s=300){let o={pos:new BABYLON.Vector3(t.x,t.y,t.z),dir:new BABYLON.Vector3(e.x,e.y,e.z),aperture:i,color:r,intensity:s,lookAt:function(t){let e=t.subtract(this.pos);this.dir.x=e.x,this.dir.y=e.y,this.dir.z=e.z}};return this.spotLights.push(o),o}getSpotLight(t){return this.spotLights[t]}removeSpotLight(t){return this.spotLights.splice(t,1)[0]}addAmbientLight(t){return this.ambientLight={color:t},this.ambientLight}removeAmbientLight(){let t=this.ambientLight.color;return this.ambientLight={color:BABYLON.Vector4.Zero()},t}render(t,e){e.matricesNeedUpdate&&e.updateMatrices(),this.meshes.forEach(i=>i.display(t,e.uVMatrix,e.uPMatrix,e.uVInvMatrix,this.pointLights,this.spotLights,this.ambientLight))}}class o{constructor(t={pos:new BABYLON.Vector3(0,0,0),target:new BABYLON.Vector3(0,0,0),fov:45,aspectRatio:16/9,near:.1,far:1e4}){this.pos=void 0!==t.pos?t.pos:new BABYLON.Vector3(0,0,0),this.target=void 0!==t.target?t.target:new BABYLON.Vector3(0,0,0),this.fov=void 0!==t.fov?t.fov:45,this.aspectRatio=void 0!==t.aspectRatio?t.aspectRatio:16/9,this.near=void 0!==t.near?t.near:.1,this.far=void 0!==t.far?t.far:1e4,this.matricesNeedUpdate=!0}updateMatrices(){this.uVMatrix=BABYLON.Matrix.LookAtRH(this.pos,this.target,BABYLON.Vector3.Up()),this.uPMatrix=BABYLON.Matrix.PerspectiveFovRH(this.fov,this.aspectRatio,this.near,this.far),this.uVInvMatrix=BABYLON.Matrix.Invert(this.uVMatrix),this.matricesNeedUpdate=!1}setDirection(t){this.target=this.pos.add(t),this.matricesNeedUpdate=!0}lookAt(t){this.target=t,this.matricesNeedUpdate=!0}setPosition(t){this.pos=t,this.matricesNeedUpdate=!0}}class a{constructor(){this.vertices=[],this.faces=[],this.vertexNormalsComputed=!1}addVertex(t,e=BABYLON.Vector3.Zero(),i=BABYLON.Vector2.Zero()){let r={pos:t,normal:e,texCoords:i};return this.vertices.push(r),r}getVertex(t){return t>=0&&t<this.vertices.length?this.vertices[t]:void 0}addFace(t,e,i,r){let s=this.vertices[e].pos.subtract(this.vertices[t].pos),o=this.vertices[i].pos.subtract(this.vertices[t].pos);void 0===r&&(r=BABYLON.Vector3.Normalize(BABYLON.Vector3.Cross(s,o)));let a={v1:this.vertices[t],v2:this.vertices[e],v3:this.vertices[i],normal:r};return this.faces.push(a),a}getFace(t){return t>=0&&t<this.faces.length?this.faces[t]:void 0}setNormal(t,e){t>=0&&t<this.vertices.length&&(this.vertices[t].normal=e)}getNormal(t){return t>=0&&t<this.vertices.length?this.vertices[t].normal:void 0}computeVertexNormals(){let t=[];this.vertices.forEach(e=>{let i;if(void 0!=(i=t.find(t=>t.pos.equals(e.pos))))return void(e.normal=i.normal);let r=this.faces.filter(t=>t.v1.pos.equals(e.pos)||t.v2.pos.equals(e.pos)||t.v3.pos.equals(e.pos)),s=BABYLON.Vector3.Zero();r.forEach(t=>s.addInPlace(t.normal)),e.normal=s.normalize(),t.push({pos:e.pos,normal:e.normal})}),this.vertexNormalsComputed=!0}}class n{constructor(t,e,i){this.locations={};let r=t.gl.createProgram();if(null===r)throw"Can't create program";this.handle=r;let s=t.gl.createShader(t.gl.VERTEX_SHADER);if(null===s)throw"Can't create vertex shader";let o=t.gl.createShader(t.gl.FRAGMENT_SHADER);if(null===o)throw"Can't create fragment shader";if(t.gl.shaderSource(s,e),t.gl.shaderSource(o,i),t.gl.compileShader(s),0==t.gl.getShaderParameter(s,t.gl.COMPILE_STATUS))throw t.gl.getShaderInfoLog(s);if(t.gl.compileShader(o),0==t.gl.getShaderParameter(o,t.gl.COMPILE_STATUS))throw t.gl.getShaderInfoLog(o);if(t.gl.attachShader(this.handle,s),t.gl.attachShader(this.handle,o),t.gl.bindAttribLocation(this.handle,0,"aPosition"),t.gl.bindAttribLocation(this.handle,1,"aNormal"),t.gl.linkProgram(this.handle),0==t.gl.getProgramParameter(this.handle,t.gl.LINK_STATUS))throw t.gl.getProgramInfoLog(this.handle);if(t.gl.validateProgram(this.handle),0==t.gl.getProgramParameter(this.handle,t.gl.VALIDATE_STATUS))throw t.gl.getProgramInfoLog(this.handle);t.gl.deleteShader(s),t.gl.deleteShader(o)}bind(t){t.gl.useProgram(this.handle)}unbind(t){t.gl.useProgram(null)}setUniform(t,e,i){if(void 0===this.locations[e]){let i=t.gl.getUniformLocation(this.handle,e);if(null===i)return void console.error(`'${e}' uniform variable was not found !`);this.locations[e]=i}"number"==typeof i?t.gl.uniform1f(this.locations[e],i):i instanceof BABYLON.Vector2?t.gl.uniform2fv(this.locations[e],i.asArray()):i instanceof BABYLON.Vector4?t.gl.uniform4fv(this.locations[e],i.asArray()):i instanceof BABYLON.Vector3?t.gl.uniform3fv(this.locations[e],i.asArray()):i instanceof BABYLON.Color4?t.gl.uniform4fv(this.locations[e],i.asArray()):i instanceof BABYLON.Matrix&&t.gl.uniformMatrix4fv(this.locations[e],!1,i.asArray())}}class l{constructor(t,e){this.programs={},this.vertexSource=t,this.fragmentSource=e}getVertexSource(){return this.vertexSource}getFragmentSource(){return this.fragmentSource}initProgram(t){this.programs[t.id]=new n(t,this.vertexSource,this.fragmentSource)}bind(t){this.programs[t.id].bind(t)}unbind(t){this.programs[t.id].unbind(t)}setUniforms(t,e){throw"Method not yet implemented !"}clone(){return new l(this.vertexSource,this.fragmentSource)}}var h=function(t,e,i,r){return new(i||(i=Promise))(function(s,o){function a(t){try{l(r.next(t))}catch(t){o(t)}}function n(t){try{l(r.throw(t))}catch(t){o(t)}}function l(t){t.done?s(t.value):new i(function(e){e(t.value)}).then(a,n)}l((r=r.apply(t,e||[])).next())})};class d extends l{constructor(t={color:new BABYLON.Vector4(1,1,1,1),diffuse:1,specular:1,shininess:1}){super(L.phongMaterialVertexShader,L.phongMaterialFragmentShader),this.specular=1,this.shininess=1,this.diffuse=1,this.color=void 0===t.color?new BABYLON.Vector4(1,1,1,1):t.color,this.diffuse=void 0===t.diffuse?1:t.diffuse,this.specular=void 0===t.specular?1:t.specular,this.shininess=void 0===t.shininess?1:t.shininess,this.texture=void 0}loadTexture(){return h(this,void 0,void 0,function*(){})}isTextured(){return void 0===this.texture}setColor(t,e,i,r){t instanceof BABYLON.Vector4?this.color=t:void 0!==e&&void 0!==i?void 0!==r?(this.color.x=t,this.color.y=e,this.color.z=i,this.color.w=r):(this.color.x=t,this.color.y=e,this.color.z=i,this.color.w=1):(this.color.x=t,this.color.y=t,this.color.z=t,this.color.w=t)}setUniforms(t,e){this.programs[t.id].setUniform(t,"uMMatrix",e.uMMatrix),this.programs[t.id].setUniform(t,"uVMatrix",e.uVMatrix),this.programs[t.id].setUniform(t,"uPMatrix",e.uPMatrix),this.programs[t.id].setUniform(t,"uVInvMatrix",e.uVInvMatrix),this.programs[t.id].setUniform(t,"uALight.color",e.ambientLight.color),this.programs[t.id].setUniform(t,"uNbPLights",e.pointLights.length),e.pointLights.forEach((e,i)=>{this.programs[t.id].setUniform(t,`uPLights[${i}].pos`,e.pos),this.programs[t.id].setUniform(t,`uPLights[${i}].color`,e.color),this.programs[t.id].setUniform(t,`uPLights[${i}].intensity`,e.intensity)}),this.programs[t.id].setUniform(t,"uNbSLights",e.spotLights.length),e.spotLights.forEach((e,i)=>{this.programs[t.id].setUniform(t,`uSLights[${i}].pos`,e.pos),this.programs[t.id].setUniform(t,`uSLights[${i}].dir`,e.dir),this.programs[t.id].setUniform(t,`uSLights[${i}].aper`,e.aperture),this.programs[t.id].setUniform(t,`uSLights[${i}].color`,e.color),this.programs[t.id].setUniform(t,`uSLights[${i}].intensity`,e.intensity)}),this.programs[t.id].setUniform(t,"uNormalMatrix",e.uNormalMatrix),this.programs[t.id].setUniform(t,"color",this.color),this.programs[t.id].setUniform(t,"diffuse",this.diffuse),this.programs[t.id].setUniform(t,"specular",this.specular),this.programs[t.id].setUniform(t,"shininess",this.shininess)}clone(){return new d({color:this.color,diffuse:this.diffuse,specular:this.specular,shininess:this.shininess})}}var c=function(t,e,i,r){return new(i||(i=Promise))(function(s,o){function a(t){try{l(r.next(t))}catch(t){o(t)}}function n(t){try{l(r.throw(t))}catch(t){o(t)}}function l(t){t.done?s(t.value):new i(function(e){e(t.value)}).then(a,n)}l((r=r.apply(t,e||[])).next())})};class u{constructor(t=new a,e=new d){this.visible=!0,this.bufferList={},this.geometry=t,this.material=e,this.pos=BABYLON.Vector3.Zero(),this.rot=BABYLON.Vector3.Zero(),this.scl=new BABYLON.Vector3(1,1,1),this.matricesNeedUpdate=!0}translate(t,e=0,i=0){t instanceof BABYLON.Vector3?this.pos.addInPlace(t):this.pos.addInPlace(new BABYLON.Vector3(t,e,i)),this.matricesNeedUpdate=!0}translateX(t){this.pos.x+=t,this.matricesNeedUpdate=!0}translateY(t){this.pos.y+=t,this.matricesNeedUpdate=!0}translateZ(t){this.pos.z+=t,this.matricesNeedUpdate=!0}scale(t,e=t,i=t){t instanceof BABYLON.Vector3?this.scl.multiplyInPlace(t):this.scl.multiplyInPlace(new BABYLON.Vector3(t,e,i)),this.matricesNeedUpdate=!0}forward(t,e=BABYLON.Vector3.Zero()){let i=BABYLON.Matrix.Identity().multiply(BABYLON.Matrix.RotationX(this.rot.x+e.x)).multiply(BABYLON.Matrix.RotationY(this.rot.y+e.y)).multiply(BABYLON.Matrix.RotationZ(this.rot.z+e.z));this.translate(BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Forward(),i).normalize().multiplyByFloats(t,t,t))}scaleX(t){this.scl.x*=t,this.matricesNeedUpdate=!0}scaleY(t){this.scl.y*=t,this.matricesNeedUpdate=!0}scaleZ(t){this.scl.z*=t,this.matricesNeedUpdate=!0}rotate(t,e,i){this.rot.x+=t,this.rot.y+=e,this.rot.z+=i,this.matricesNeedUpdate=!0}rotateX(t){this.rot.x+=t,this.matricesNeedUpdate=!0}rotateY(t){this.rot.y+=t,this.matricesNeedUpdate=!0}rotateZ(t){this.rot.z+=t,this.matricesNeedUpdate=!0}requestGeometryUpdate(t){for(let e in this.bufferList)this.bufferList.hasOwnProperty(e)&&(this.bufferList[e].geometryNeedUpdate=t)}requstMaterialUpdate(t){for(let e in this.bufferList)this.bufferList.hasOwnProperty(e)&&(this.bufferList[e].materialNeedUpdate=t)}updateMatrices(){this.uMMatrix=BABYLON.Matrix.Identity(),this.uMMatrix=BABYLON.Matrix.Translation(this.pos.x,this.pos.y,this.pos.z).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.Scaling(this.scl.x,this.scl.y,this.scl.z).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.RotationX(this.rot.x).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.RotationY(this.rot.y).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.RotationZ(this.rot.z).multiply(this.uMMatrix),this.uNormalMatrix=BABYLON.Matrix.Transpose(BABYLON.Matrix.Invert(this.uMMatrix)),this.matricesNeedUpdate=!1}computeVertexNormals(){this.geometry.computeVertexNormals(),this.requestGeometryUpdate(!0)}genBuffers(t){let e=[],i=[],r=[],s=[];void 0===this.bufferList[t.id]?this.bufferList[t.id]={materialNeedUpdate:!0,geometryNeedUpdate:!0}:(t.gl.deleteBuffer(this.bufferList[t.id].vbuffer),t.gl.deleteBuffer(this.bufferList[t.id].nbuffer),t.gl.deleteBuffer(this.bufferList[t.id].wvbuffer),t.gl.deleteBuffer(this.bufferList[t.id].wnbuffer)),this.geometry.faces.forEach((t,o)=>{let a,n=[[...t.v1.pos.asArray()],[...t.v2.pos.asArray()],[...t.v3.pos.asArray()]],l=[...t.normal.asArray()];a=this.geometry.vertexNormalsComputed?[[...t.v1.normal.asArray()],[...t.v2.normal.asArray()],[...t.v3.normal.asArray()]]:[l,l,l],e.push(...n[0],...n[1],...n[2]),r.push(...n[0],...n[1],...n[1],...n[2],...n[2],...n[0]),i.push(...a[0],...a[1],...a[2]),s.push(...a[0],...a[1],...a[1],...a[2],...a[2],...a[0])});let o=t.gl.createBuffer();if(null===o)throw"Couldn't create buffer";this.bufferList[t.id].vbuffer=o,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].vbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(e),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);let a=t.gl.createBuffer();if(null===a)throw"Couldn't create buffer";this.bufferList[t.id].nbuffer=a,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].nbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(i),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);let n=t.gl.createBuffer();if(null===n)throw"Couldn't create buffer";this.bufferList[t.id].wvbuffer=n,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].wvbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(r),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);let l=t.gl.createBuffer();if(null===l)throw"Couldn't create buffer";this.bufferList[t.id].wnbuffer=l,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].wnbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(s),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),this.bufferList[t.id].geometryNeedUpdate=!1}updateMaterial(t){this.material.initProgram(t),this.bufferList[t.id].materialNeedUpdate=!1}display(t,e,i,r,s,o,a){if(!this.visible)return;this.matricesNeedUpdate&&this.updateMatrices(),(void 0===this.bufferList[t.id]||this.bufferList[t.id].geometryNeedUpdate)&&this.genBuffers(t),this.bufferList[t.id].materialNeedUpdate&&this.updateMaterial(t);let n={uMMatrix:this.uMMatrix,uVMatrix:e,uPMatrix:i,uVInvMatrix:r,uNormalMatrix:this.uNormalMatrix,pointLights:s,spotLights:o,ambientLight:a};this.material.bind(t),this.material.setUniforms(t,n),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wvbuffer:this.bufferList[t.id].vbuffer),t.gl.vertexAttribPointer(0,3,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wnbuffer:this.bufferList[t.id].nbuffer),t.gl.vertexAttribPointer(1,3,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),t.gl.enableVertexAttribArray(0),t.gl.enableVertexAttribArray(1),t.gl.drawArrays(t.getMode(),0,(t.getMode()==t.gl.LINES?2:1)*this.geometry.faces.length*3),t.gl.disableVertexAttribArray(1),t.gl.disableVertexAttribArray(0),this.material.unbind(t)}static loadObj(t,e){let i=new u(void 0,e),r=[];return t.split("\n").forEach(t=>{let e=t.replace(/\s+/g," ").trim().split(" ");"v"==e[0]?i.geometry.addVertex(new BABYLON.Vector3(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]))):"f"==e[0]&&r.push({v1:parseInt(e[1])-1,v2:parseInt(e[2])-1,v3:parseInt(e[3])-1})}),r.forEach(t=>i.geometry.addFace(t.v1,t.v2,t.v3)),i.requestGeometryUpdate(!0),i}static loadObjAsync(t,e){return c(this,void 0,void 0,function*(){let i=new u(void 0,e),r=[];return t.split("\n").forEach(t=>{let e=t.replace(/\s+/g," ").trim().split(" ");"v"==e[0]?i.geometry.addVertex(new BABYLON.Vector3(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]))):"f"==e[0]&&r.push({v1:parseInt(e[1])-1,v2:parseInt(e[2])-1,v3:parseInt(e[3])-1})}),r.forEach(t=>i.geometry.addFace(t.v1,t.v2,t.v3)),i.requestGeometryUpdate(!0),i})}}class f extends l{constructor(t){super(L.baseMaterialVertexShader,L.baseMaterialFragmentShader),this.color=t}setColor(t,e,i,r){t instanceof BABYLON.Vector4?this.color=t:void 0!==e&&void 0!==i?void 0!==r?(this.color.x=t,this.color.y=e,this.color.z=i,this.color.w=r):(this.color.x=t,this.color.y=e,this.color.z=i,this.color.w=1):(this.color.x=t,this.color.y=t,this.color.z=t,this.color.w=t)}setUniforms(t,e){this.programs[t.id].setUniform(t,"uMMatrix",e.uMMatrix),this.programs[t.id].setUniform(t,"uVMatrix",e.uVMatrix),this.programs[t.id].setUniform(t,"uPMatrix",e.uPMatrix),this.programs[t.id].setUniform(t,"color",this.color)}clone(){return new f(this.color)}}class g extends a{constructor(t,e=t,i=2){super();let r=t/i,s=e/i,o=t/2,a=e/2;this.grid=[];for(let n=0;n<=i;n++){this.grid[n]=[];for(let l=0;l<=i;l++)this.grid[n][l]=this.addVertex(new BABYLON.Vector3(l*r-o,0,n*s-a),BABYLON.Vector3.Up(),new BABYLON.Vector2(l*r/t,n*s/e))}for(let t=0;t<this.grid.length-1;t++)for(let e=0;e<this.grid[t].length-1;e++){let i=e+t*this.grid[t].length,r=e+1+t*this.grid[t].length,s=e+(t+1)*this.grid[t].length,o=e+1+(t+1)*this.grid[t].length;this.addFace(i,r,s),this.addFace(r,s,o)}this.vertexNormalsComputed=!0}}class m extends a{constructor(t,e=20){super();let i=2*Math.PI/e,r=[],s=Math.PI,o=s/2;for(let e=-s,a=0;e<=s+i;e+=i,a++){let s=[];r.push(s);for(let r=-o,a=0;r<=o+i;r+=i,a++){let i=t*Math.sin(e)*Math.cos(r),o=t*Math.sin(e)*Math.sin(r),a=t*Math.cos(e);s.push(new BABYLON.Vector3(i,o,a))}}for(let t=0;t<r.length;t++)for(let e=0;e<r[t].length;e++)this.addVertex(r[t][e],r[t][e].clone().normalize());i=Math.floor(2*Math.PI/i);for(let t=0;t<r.length-1;t++)for(let e=0;e<r[t].length-1;e++){let i=e+t*r[t].length,s=e+1+t*r[t].length,o=e+(t+1)*r[t].length,a=e+1+(t+1)*r[t].length;this.addFace(i,s,o),this.addFace(s,o,a)}this.vertexNormalsComputed=!0}}class p extends a{constructor(t,e,i){super();let r=2*Math.PI/i,s=[],o=Math.PI;for(let i=-o;i<=o+r;i+=r){let a=[];s.push(a);for(let s=-o;s<=o+r;s+=r){let r=(t+e*Math.cos(i))*Math.cos(s),o=(t+e*Math.cos(i))*Math.sin(s),n=e*Math.sin(i);a.push({lon:i,lat:s,pos:new BABYLON.Vector3(r,o,n)})}}for(let e=0;e<s.length;e++)for(let i=0;i<s[e].length;i++)this.addVertex(s[e][i].pos,s[e][i].pos.subtractFromFloats(t*Math.cos(s[e][i].lat),t*Math.sin(s[e][i].lat),0));for(let t=0;t<s.length-1;t++)for(let e=0;e<s[t].length-1;e++){let i=e+(t+1)*s[t].length,r=e+t*s[t].length,o=e+1+t*s[t].length,a=e+1+(t+1)*s[t].length;this.addFace(i,r,a),this.addFace(r,o,a)}this.vertexNormalsComputed=!0}}class v extends u{constructor(t){super(new m(2,20),new f(t.color)),this.pos=t.pos,this.currentPos=this.pos.clone()}display(t,e,i,r,s,o,a){this.currentPos.equals(this.pos)||(this.currentPos=this.pos.clone(),this.updateMatrices()),(void 0===this.bufferList[t.id]||this.bufferList[t.id].geometryNeedUpdate)&&this.genBuffers(t),this.bufferList[t.id].materialNeedUpdate&&this.updateMaterial(t),this.material.bind(t),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wvbuffer:this.bufferList[t.id].vbuffer),t.gl.vertexAttribPointer(0,3,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wnbuffer:this.bufferList[t.id].nbuffer),t.gl.vertexAttribPointer(1,3,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),t.gl.enableVertexAttribArray(0),t.gl.enableVertexAttribArray(1),this.material.setUniforms(t,{uMMatrix:this.uMMatrix,uVMatrix:e,uPMatrix:i}),t.gl.drawArrays(t.getMode(),0,(t.getMode()==t.gl.LINES?2:1)*this.geometry.faces.length*3),t.gl.disableVertexAttribArray(1),t.gl.disableVertexAttribArray(0),this.material.unbind(t)}}var L;!function(t){t.phongMaterialVertexShader=`        precision mediump   float;\n        precision mediump   int;\n\n        attribute vec3      aPosition;\n        attribute vec3      aNormal;\n\n        uniform mat4        uMMatrix;\n        uniform mat4        uVMatrix;\n        uniform mat4        uPMatrix;\n\n        uniform mat4        uNormalMatrix;\n\n        varying vec4        normal;\n        varying vec4        mPos;\n        varying vec4        mvPos;\n\n        void main() {\n            mPos = uMMatrix * vec4(aPosition, 1.0);\n            mvPos = uVMatrix * mPos;\n            gl_Position = uPMatrix * mvPos;\n\n            normal = vec4(aNormal, 1);\n        }`,t.phongMaterialFragmentShader=`\n        precision mediump   float;\n        precision mediump   int;\n\n        struct      PointLight {\n            vec3    pos;\n            vec4    color;\n            float   intensity;\n        };\n\n        struct      SpotLight {\n            vec3    pos;\n            vec3    dir;\n            float   aper;\n            vec4    color;\n            float   intensity;\n        };\n\n        struct      AmbientLight {\n            vec4    color;\n        };\n\n        uniform mat4            uVInvMatrix;\n        uniform mat4            uNormalMatrix;\n\n        uniform float           uNbPLights;\n        uniform float           uNbSLights;\n\n        uniform PointLight      uPLights[20];\n        uniform SpotLight       uSLights[20];\n        uniform AmbientLight    uALight;\n\n        uniform vec4            color;\n        uniform float           diffuse;\n        uniform float           specular;\n        uniform float           shininess;\n\n        varying vec4            normal;\n        varying vec4            mPos;\n        varying vec4            mvPos;\n\n        float       getSpecCoef(vec4 vertexToCamera, vec4 vertexToLight, vec4 finalNormal) {\n            if (dot(vertexToLight, finalNormal) < 0.0)\n                return 0.0;\n            return pow(max(dot(reflect(-vertexToLight, finalNormal), vertexToCamera), 0.0), shininess) * specular;\n        }\n\n        float       getDiffuseCoef(vec4 vertexToLight, vec4 finalNormal) {\n            return max(dot(vertexToLight, finalNormal), 0.0) * diffuse;\n        }\n\n        void        main() {\n            vec4    finalNormal = uNormalMatrix * normal;\n            vec4    camera = uVInvMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n            vec4    vertexToCamera = normalize(camera - mPos);\n            vec4    diffuseColors = vec4(0.0, 0.0, 0.0, 1.0), specColors = vec4(0.0, 0.0, 0.0, 1.0);\n            float   attenuation = 0.0;\n\n            if ((uNbPLights + uNbSLights) != 0.0) {\n                for (int idx = 0; idx < 20; idx++) {\n                    if (idx < int(uNbPLights)) {\n                        vec4 vertexToLight = vec4(uPLights[idx].pos, 1) - mPos;\n                        float attenuation = clamp(1.0 / length(vertexToLight) * uPLights[idx].intensity, 0.0, 1.0);\n\n                        vertexToLight = normalize(vertexToLight);\n\n                        diffuseColors += clamp(getDiffuseCoef(vertexToLight, finalNormal) * color * uPLights[idx].color, 0.0, 1.0) * attenuation;\n                        specColors += clamp(getSpecCoef(vertexToCamera, vertexToLight, finalNormal) * color * uPLights[idx].color, 0.0, 1.0) * attenuation;\n                    }\n                    if (idx < int(uNbSLights)) {\n                        vec4 vertexToLight = vec4(uSLights[idx].pos, 1) - mPos;\n                        float attenuation = clamp(1.0 / length(vertexToLight) * uSLights[idx].intensity, 0.0, 1.0);\n\n                        vertexToLight = normalize(vertexToLight);\n                        float angle = degrees(acos(dot(-vertexToLight, vec4(normalize(uSLights[idx].dir), 1))));\n\n                        if (angle <= uSLights[idx].aper) {\n                            diffuseColors += clamp(getDiffuseCoef(vertexToLight, finalNormal) * color * uSLights[idx].color, 0.0, 1.0) * attenuation;\n                            specColors += clamp(getSpecCoef(vertexToCamera, vertexToLight, finalNormal) * color * uSLights[idx].color, 0.0, 1.0) * attenuation;\n                        }\n                    }\n                }\n\n                diffuseColors = clamp(diffuseColors, 0.0, 1.0);\n                specColors = clamp(specColors, 0.0, 1.0);\n            }\n\n            gl_FragColor = uALight.color + diffuseColors + specColors;\n        }`,t.baseMaterialVertexShader=`        precision mediump   float;\n        precision mediump   int;\n\n        attribute vec3      aPosition;\n    \n        uniform mat4        uMMatrix;\n        uniform mat4        uVMatrix;\n        uniform mat4        uPMatrix;\n    \n        void main() {\n            gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aPosition, 1);\n        }`,t.baseMaterialFragmentShader=`        precision mediump   float;\n        precision mediump   int;\n\n        uniform vec4        color;\n\n        void main() {\n            gl_FragColor = color;\n        }`}(L||(L={}));var x=function(t,e,i,r){return new(i||(i=Promise))(function(s,o){function a(t){try{l(r.next(t))}catch(t){o(t)}}function n(t){try{l(r.throw(t))}catch(t){o(t)}}function l(t){t.done?s(t.value):new i(function(e){e(t.value)}).then(a,n)}l((r=r.apply(t,e||[])).next())})};let A=new r("draw"),B=new r("draw2"),M=new o({aspectRatio:A.canvas.width/A.canvas.height}),b=new o({aspectRatio:B.canvas.width/B.canvas.height}),N=new s,y={plane:new d({diffuse:1,specular:.1,shininess:10}),car:new d({diffuse:15,specular:5,shininess:10}),dragon:new d({diffuse:50,specular:1,shininess:10}),teapot:new d({diffuse:10,specular:1,shininess:10}),crank:new d({diffuse:30,specular:1,shininess:30}),sphere:new d({diffuse:20,specular:1,shininess:20})},w={plane:new u(new g(2e3,2e3,20),y.plane),sphere:new u(new p(2,1,50),y.sphere)};if(i.async("models/test.obj").then(t=>x(void 0,void 0,void 0,function*(){w.car=yield u.loadObjAsync(t,y.car),w.car.translateX(100),w.car.scale(15),N.addMesh(w.car)})),i.async("models/dragon.obj").then(t=>x(void 0,void 0,void 0,function*(){w.dragon=yield u.loadObjAsync(t,y.dragon),w.dragon.scale(50),w.dragon.rotateX(-10*Math.PI/180),w.dragon.translateY(25),w.dragon.translateZ(-50),N.addMesh(w.dragon)})),i.async("models/teapot.obj").then(t=>x(void 0,void 0,void 0,function*(){w.teapot=yield u.loadObjAsync(t,y.teapot),w.teapot.scale(10),w.teapot.computeVertexNormals(),w.teapot.translateZ(50),N.addMesh(w.teapot)})),i.async("models/crank.obj").then(t=>x(void 0,void 0,void 0,function*(){w.crank=yield u.loadObjAsync(t,y.crank),w.crank.scale(30),w.crank.translateX(-100),w.crank.translateY(50),N.addMesh(w.crank)})),void 0==w.plane)throw"LoadingError";if(N.addMesh(w.plane),void 0==w.sphere)throw"LoadingError";w.sphere.scale(20),w.sphere.translateX(-100),w.sphere.translateY(150),N.addMesh(w.sphere);let P=N.addPointLight(new BABYLON.Vector3(100,20,20),new BABYLON.Vector4(39/255,174/255,96/255,1)),U=N.addPointLight(new BABYLON.Vector3(-60,100,20),new BABYLON.Vector4(231/255,76/255,60/255,1)),Y=N.addSpotLight(new BABYLON.Vector3(400,400,400),new BABYLON.Vector3(400,400,400),30,new BABYLON.Vector4(1,1,1,1),100);Y.lookAt(BABYLON.Vector3.Zero());N.addMesh(new v(P)),N.addMesh(new v(U));let V=N.addMesh(new v(Y));M.lookAt(BABYLON.Vector3.Zero()),b.lookAt(BABYLON.Vector3.Zero());let R=0,S=.01,F=0,O=0;setInterval(()=>{P.pos.x=50*Math.cos(R),P.pos.y=50*Math.sin(R),U.pos.x=50*Math.cos(F),U.pos.z=50*Math.sin(F),Y.pos.x=400*Math.cos(O),Y.pos.z=400*Math.sin(O),Y.lookAt(BABYLON.Vector3.Zero()),R>=Math.PI?S=-.01:R<=0&&(S=.01),R+=S,F>=2*Math.PI&&(F=0),F+=.01,O>=2*Math.PI&&(O=0),O+=-.005,w.teapot&&w.teapot.rotateY(.01),w.crank&&w.crank.rotate(.01,.01,.01),w.sphere.rotate(.01,.01,.01)}),console.log(N);let I=0,T=!1,E={distance:200,mode:0};document.addEventListener("contextmenu",t=>t.preventDefault()),document.addEventListener("mousewheel",t=>E.distance-=t.deltaY>0?-10:10),document.addEventListener("keypress",t=>{"w"==t.key?A.setMode(A.getModeIdx()+1):"e"==t.key&&(T=!T)});let C=new dat.GUI({autoPlace:!0,name:"Scene control"}),_=C.addFolder("Scene");_.add(E,"distance",0,750),_.add(E,"mode",{Standard:0,Wireframe:1,Points:2}).onChange=(t=>{A.setMode(E.mode),E.mode=A.getModeIdx()}),(_=C.addFolder("Spotlight")).add(Y,"intensity",0,700),_.add(V,"visible"),(_=_.addFolder("Color")).add(Y.color,"x",0,1),_.add(Y.color,"y",0,1),_.add(Y.color,"z",0,1),_.add(Y.color,"w",0,1),t()}();
