!function(){"use strict";class t{constructor(){this.vertices=[],this.faces=[],this.vertexNormalsComputed=!1}addVertex(t,e=BABYLON.Vector3.Zero(),i=BABYLON.Vector2.Zero()){const r={pos:t,normal:e,texCoords:i};return this.vertices.push(r),r}getVertex(t){return t>=0&&t<this.vertices.length?this.vertices[t]:void 0}addFace(t,e,i,r,s,o,a){const n=this.vertices[e].pos.subtract(this.vertices[t].pos),h=this.vertices[i].pos.subtract(this.vertices[t].pos);void 0===r&&(r=BABYLON.Vector3.Normalize(BABYLON.Vector3.Cross(n,h))),void 0===s&&(s=BABYLON.Vector2.Zero()),void 0===o&&(o=BABYLON.Vector2.Zero()),void 0===a&&(a=BABYLON.Vector2.Zero());const l={v1:this.vertices[t],v2:this.vertices[e],v3:this.vertices[i],normal:r,t1:s,t2:o,t3:a};return this.faces.push(l),l}getFace(t){return t>=0&&t<this.faces.length?this.faces[t]:void 0}setNormal(t,e){t>=0&&t<this.vertices.length&&(this.vertices[t].normal=e)}getNormal(t){return t>=0&&t<this.vertices.length?this.vertices[t].normal:void 0}computeVertexNormals(){const t=[];this.vertices.forEach(e=>{let i;if(void 0!=(i=t.find(t=>t.pos.equals(e.pos))))return void(e.normal=i.normal);const r=this.faces.filter(t=>t.v1.pos.equals(e.pos)||t.v2.pos.equals(e.pos)||t.v3.pos.equals(e.pos)),s=BABYLON.Vector3.Zero();r.forEach(t=>s.addInPlace(t.normal)),e.normal=s.normalize(),t.push({pos:e.pos,normal:e.normal})}),this.vertexNormalsComputed=!0}}class e{constructor(t,e,i){this.locations={};let r=t.gl.createProgram();if(null===r)throw"Can't create program";this.handle=r;let s=t.gl.createShader(t.gl.VERTEX_SHADER);if(null===s)throw"Can't create vertex shader";let o=t.gl.createShader(t.gl.FRAGMENT_SHADER);if(null===o)throw"Can't create fragment shader";if(t.gl.shaderSource(s,e),t.gl.shaderSource(o,i),t.gl.compileShader(s),0==t.gl.getShaderParameter(s,t.gl.COMPILE_STATUS))throw t.gl.getShaderInfoLog(s);if(t.gl.compileShader(o),0==t.gl.getShaderParameter(o,t.gl.COMPILE_STATUS))throw t.gl.getShaderInfoLog(o);if(t.gl.attachShader(this.handle,s),t.gl.attachShader(this.handle,o),t.gl.bindAttribLocation(this.handle,0,"aPosition"),t.gl.bindAttribLocation(this.handle,1,"aNormal"),t.gl.linkProgram(this.handle),0==t.gl.getProgramParameter(this.handle,t.gl.LINK_STATUS))throw t.gl.getProgramInfoLog(this.handle);if(t.gl.validateProgram(this.handle),0==t.gl.getProgramParameter(this.handle,t.gl.VALIDATE_STATUS))throw t.gl.getProgramInfoLog(this.handle);t.gl.deleteShader(s),t.gl.deleteShader(o)}bind(t){t.gl.useProgram(this.handle)}unbind(t){t.gl.useProgram(null)}setUniform(t,e,i,r){if(void 0===this.locations[e]){let i=t.gl.getUniformLocation(this.handle,e);if(null===i)return void console.error(`'${e}' uniform variable was not found !`);this.locations[e]=i}r||("number"==typeof i?r="float":"boolean"==typeof i?r="boolean":i instanceof BABYLON.Vector2?r="vector2":i instanceof BABYLON.Vector3?r="vector3":i instanceof BABYLON.Vector4?r="vector4":i instanceof BABYLON.Color4?r="vector4":i instanceof BABYLON.Matrix&&(r="matrix4")),"float"==r?t.gl.uniform1f(this.locations[e],i):"boolean"==r||"int"==r?t.gl.uniform1i(this.locations[e],"boolean"==r?i?1:0:i):"vector2"==r?t.gl.uniform2fv(this.locations[e],i.asArray()):"vector3"==r?t.gl.uniform3fv(this.locations[e],i.asArray()):"vector4"==r?t.gl.uniform4fv(this.locations[e],i.asArray()):"matrix4"==r&&t.gl.uniformMatrix4fv(this.locations[e],!1,i.asArray())}}function i(t,e,i,r,s){return(t-e)*(s-r)/(i-e)+r}function r(t,e,i,r){const s=i-t,o=r-e;return Math.sqrt(s*s+o*o)}class s{get identifier(){return"Material"}get hasTexture(){return this._hasTexture}constructor(t,e,i){this.programs={},this.vertexSource=t,this.fragmentSource=e,void 0!==i?(this._hasTexture=!0,this.texture=i):this._hasTexture=!1}getVertexSource(){return this.vertexSource}getFragmentSource(){return this.fragmentSource}initProgram(t){t.programs[this.identifier]=new e(t,this.vertexSource,this.fragmentSource)}bind(t){t.programs[this.identifier].bind(t)}unbind(t){t.programs[this.identifier].unbind(t)}setUniforms(t,e){throw"Method not yet implemented !"}clone(){return new s(this.vertexSource,this.fragmentSource)}}var o="\nprecision mediump   float;\nprecision mediump   int;\n\nattribute vec3      aPosition;\nattribute vec3      aNormal;\nattribute vec2      aTexCoord;\n\nuniform mat4        uMMatrix;\nuniform mat4        uVMatrix;\nuniform mat4        uPMatrix;\n\nuniform mat4        uNormalMatrix;\n\nvarying vec4        normal;\nvarying vec4        mPos;\nvarying vec4        mvPos;\nvarying vec2        texCoord;\n\nvoid main() {\n    mPos = uMMatrix * vec4(aPosition, 1.0);\n    mvPos = uVMatrix * mPos;\n    gl_Position = uPMatrix * mvPos;\n\n    normal = vec4(aNormal, 1);\n    texCoord = aTexCoord;\n}",a="\nprecision mediump   float;\nprecision mediump   int;\n\nstruct      PointLight {\n    vec3    pos;\n    vec4    color;\n    float   intensity;\n};\n\nstruct      SpotLight {\n    vec3    pos;\n    vec3    dir;\n    float   aper;\n    vec4    color;\n    float   intensity;\n};\n\nstruct      AmbientLight {\n    vec4    color;\n};\n\nuniform mat4            uVInvMatrix;\nuniform mat4            uNormalMatrix;\n\nuniform float           uNbPLights;\nuniform float           uNbSLights;\n\nuniform sampler2D       uTexture;\nuniform bool            uHasTexture;\nuniform PointLight      uPLights[20];\nuniform SpotLight       uSLights[20];\nuniform AmbientLight    uALight;\n\nuniform vec4            uColor;\nuniform float           diffuse;\nuniform float           specular;\nuniform float           shininess;\n\nvarying vec4            normal;\nvarying vec2            texCoord;\nvarying vec4            mPos;\nvarying vec4            mvPos;\n\nfloat       getSpecCoef(vec4 vertexToCamera, vec4 vertexToLight, vec4 finalNormal) {\n    if (dot(vertexToLight, finalNormal) < 0.0)\n        return 0.0;\n    return pow(max(dot(reflect(-vertexToLight, finalNormal), vertexToCamera), 0.0), shininess) * specular;\n}\n\nfloat       getDiffuseCoef(vec4 vertexToLight, vec4 finalNormal) {\n    return max(dot(vertexToLight, finalNormal), 0.0) * diffuse;\n}\n\nvoid        main() {\n    vec4    finalNormal = uNormalMatrix * normal;\n    vec4    camera = uVInvMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vec4    vertexToCamera = normalize(camera - mPos);\n    vec4    diffuseColors = vec4(0.0, 0.0, 0.0, 1.0), specColors = vec4(0.0, 0.0, 0.0, 1.0);\n    float   attenuation = 0.0;\n    vec4    color = uColor;\n\n    if (uHasTexture == true)\n        color = texture2D(uTexture, texCoord);\n\n    if ((uNbPLights + uNbSLights) != 0.0) {\n        for (int idx = 0; idx < 20; idx++) {\n            if (idx < int(uNbPLights)) {\n                vec4 vertexToLight = vec4(uPLights[idx].pos, 1) - mPos;\n                float attenuation = clamp(1.0 / length(vertexToLight) * uPLights[idx].intensity, 0.0, 1.0);\n\n                vertexToLight = normalize(vertexToLight);\n\n                diffuseColors += clamp(getDiffuseCoef(vertexToLight, finalNormal) * color * uPLights[idx].color, 0.0, 1.0) * attenuation;\n                specColors += clamp(getSpecCoef(vertexToCamera, vertexToLight, finalNormal) * color * uPLights[idx].color, 0.0, 1.0) * attenuation;\n            }\n            if (idx < int(uNbSLights)) {\n                vec4 vertexToLight = vec4(uSLights[idx].pos, 1) - mPos;\n                float attenuation = clamp(1.0 / length(vertexToLight) * uSLights[idx].intensity, 0.0, 1.0);\n\n                vertexToLight = normalize(vertexToLight);\n                float angle = degrees(acos(dot(-vertexToLight, vec4(normalize(uSLights[idx].dir), 1.0))));\n\n                if (angle <= uSLights[idx].aper) {\n                    diffuseColors += clamp(getDiffuseCoef(vertexToLight, finalNormal) * color * uSLights[idx].color, 0.0, 1.0) * attenuation;\n                    specColors += clamp(getSpecCoef(vertexToCamera, vertexToLight, finalNormal) * color * uSLights[idx].color, 0.0, 1.0) * attenuation;\n                }\n            }\n        }\n\n        diffuseColors = clamp(diffuseColors, 0.0, 1.0);\n        specColors = clamp(specColors, 0.0, 1.0);\n    }\n\n    gl_FragColor = clamp(uALight.color * color, 0.0, 1.0) + diffuseColors + specColors;\n}";class n extends s{constructor(t={color:new BABYLON.Vector4(1,1,1,1),diffuse:1,specular:1,shininess:1,texture:void 0}){super(o,a,t.texture),this.specular=1,this.shininess=1,this.diffuse=1,this.color=void 0===t.color?new BABYLON.Vector4(1,1,1,1):t.color,this.diffuse=void 0===t.diffuse?1:t.diffuse,this.specular=void 0===t.specular?1:t.specular,this.shininess=void 0===t.shininess?1:t.shininess}get identifier(){return"PhongMaterial"}setColor(t,e,i,r){t instanceof BABYLON.Vector4?this.color=t:void 0!==e&&void 0!==i?void 0!==r?(this.color.x=t,this.color.y=e,this.color.z=i,this.color.w=r):(this.color.x=t,this.color.y=e,this.color.z=i,this.color.w=1):(this.color.x=t,this.color.y=t,this.color.z=t,this.color.w=t)}setUniforms(t,e){t.programs[this.identifier].setUniform(t,"uMMatrix",e.uMMatrix),t.programs[this.identifier].setUniform(t,"uVMatrix",e.uVMatrix),t.programs[this.identifier].setUniform(t,"uPMatrix",e.uPMatrix),t.programs[this.identifier].setUniform(t,"uVInvMatrix",e.uVInvMatrix),t.programs[this.identifier].setUniform(t,"uALight.color",e.ambientLight.color),t.programs[this.identifier].setUniform(t,"uNbPLights",e.pointLights.length),e.pointLights.forEach((e,i)=>{t.programs[this.identifier].setUniform(t,`uPLights[${i}].pos`,e.pos),t.programs[this.identifier].setUniform(t,`uPLights[${i}].color`,e.color),t.programs[this.identifier].setUniform(t,`uPLights[${i}].intensity`,e.intensity)}),t.programs[this.identifier].setUniform(t,"uNbSLights",e.spotLights.length),e.spotLights.forEach((e,i)=>{t.programs[this.identifier].setUniform(t,`uSLights[${i}].pos`,e.pos),t.programs[this.identifier].setUniform(t,`uSLights[${i}].dir`,e.dir),t.programs[this.identifier].setUniform(t,`uSLights[${i}].aper`,e.aperture),t.programs[this.identifier].setUniform(t,`uSLights[${i}].color`,e.color),t.programs[this.identifier].setUniform(t,`uSLights[${i}].intensity`,e.intensity)}),t.programs[this.identifier].setUniform(t,"uNormalMatrix",e.uNormalMatrix),t.programs[this.identifier].setUniform(t,"uColor",this.color),t.programs[this.identifier].setUniform(t,"uHasTexture",this._hasTexture),t.programs[this.identifier].setUniform(t,"uTexture",0,"int"),t.programs[this.identifier].setUniform(t,"diffuse",this.diffuse),t.programs[this.identifier].setUniform(t,"specular",this.specular),t.programs[this.identifier].setUniform(t,"shininess",this.shininess)}clone(){return new n({color:this.color,diffuse:this.diffuse,specular:this.specular,shininess:this.shininess})}}class h{constructor(e=new t,i=new n){this.visible=!0,this.bufferList={},this.geometry=e,this.material=i,this.pos=BABYLON.Vector3.Zero(),this.rot=BABYLON.Vector3.Zero(),this.scl=new BABYLON.Vector3(1,1,1),this.matricesNeedUpdate=!0}translate(t,e=0,i=0){t instanceof BABYLON.Vector3?this.pos.addInPlace(t):this.pos.addInPlace(new BABYLON.Vector3(t,e,i)),this.matricesNeedUpdate=!0}translateX(t){this.pos.x+=t,this.matricesNeedUpdate=!0}translateY(t){this.pos.y+=t,this.matricesNeedUpdate=!0}translateZ(t){this.pos.z+=t,this.matricesNeedUpdate=!0}scale(t,e=t,i=t){t instanceof BABYLON.Vector3?this.scl.multiplyInPlace(t):this.scl.multiplyInPlace(new BABYLON.Vector3(t,e,i)),this.matricesNeedUpdate=!0}forward(t,e=BABYLON.Vector3.Zero()){const i=BABYLON.Matrix.Identity().multiply(BABYLON.Matrix.RotationX(this.rot.x+e.x)).multiply(BABYLON.Matrix.RotationY(this.rot.y+e.y)).multiply(BABYLON.Matrix.RotationZ(this.rot.z+e.z));this.translate(BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Forward(),i).normalize().multiplyByFloats(t,t,t))}scaleX(t){this.scl.x*=t,this.matricesNeedUpdate=!0}scaleY(t){this.scl.y*=t,this.matricesNeedUpdate=!0}scaleZ(t){this.scl.z*=t,this.matricesNeedUpdate=!0}rotate(t,e,i){this.rot.x+=t,this.rot.y+=e,this.rot.z+=i,this.matricesNeedUpdate=!0}rotateX(t){this.rot.x+=t,this.matricesNeedUpdate=!0}rotateY(t){this.rot.y+=t,this.matricesNeedUpdate=!0}rotateZ(t){this.rot.z+=t,this.matricesNeedUpdate=!0}requestGeometryUpdate(t){for(const e in this.bufferList)this.bufferList.hasOwnProperty(e)&&(this.bufferList[e].geometryNeedUpdate=t)}requstMaterialUpdate(t){for(const e in this.bufferList)this.bufferList.hasOwnProperty(e)&&(this.bufferList[e].materialNeedUpdate=t)}updateMatrices(){this.uMMatrix=BABYLON.Matrix.Identity(),this.uMMatrix=BABYLON.Matrix.Translation(this.pos.x,this.pos.y,this.pos.z).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.Scaling(this.scl.x,this.scl.y,this.scl.z).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.RotationX(this.rot.x).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.RotationY(this.rot.y).multiply(this.uMMatrix),this.uMMatrix=BABYLON.Matrix.RotationZ(this.rot.z).multiply(this.uMMatrix),this.uNormalMatrix=BABYLON.Matrix.Transpose(BABYLON.Matrix.Invert(this.uMMatrix)),this.matricesNeedUpdate=!1}computeVertexNormals(){this.geometry.computeVertexNormals(),this.requestGeometryUpdate(!0)}genBuffers(t){const e=[],i=[],r=[],s=[],o=[],a=[];void 0===this.bufferList[t.id]?this.bufferList[t.id]={materialNeedUpdate:void 0===t.programs[this.material.identifier],geometryNeedUpdate:!0}:(t.gl.deleteBuffer(this.bufferList[t.id].vbuffer),t.gl.deleteBuffer(this.bufferList[t.id].nbuffer),t.gl.deleteBuffer(this.bufferList[t.id].tbuffer),t.gl.deleteBuffer(this.bufferList[t.id].wvbuffer),t.gl.deleteBuffer(this.bufferList[t.id].wnbuffer),t.gl.deleteBuffer(this.bufferList[t.id].wtbuffer)),this.geometry.faces.forEach((t,n)=>{const h=[[...t.v1.pos.asArray()],[...t.v2.pos.asArray()],[...t.v3.pos.asArray()]],l=[...t.normal.asArray()],c=this.geometry.vertexNormalsComputed?[[...t.v1.normal.asArray()],[...t.v2.normal.asArray()],[...t.v3.normal.asArray()]]:[l,l,l],d=[[...t.t1.asArray()],[...t.t2.asArray()],[...t.t3.asArray()]];e.push(...h[0],...h[1],...h[2]),s.push(...h[0],...h[1],...h[1],...h[2],...h[2],...h[0]),i.push(...c[0],...c[1],...c[2]),o.push(...c[0],...c[1],...c[1],...c[2],...c[2],...c[0]),r.push(...d[0],...d[1],...d[2]),a.push(...d[0],...d[1],...d[1],...d[2],...d[2],...d[0])});const n=t.gl.createBuffer();if(null===n)throw"Couldn't create buffer";this.bufferList[t.id].vbuffer=n,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].vbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(e),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);const h=t.gl.createBuffer();if(null===h)throw"Couldn't create buffer";this.bufferList[t.id].nbuffer=h,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].nbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(i),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);const l=t.gl.createBuffer();if(null===l)throw"Couldn't create buffer";this.bufferList[t.id].tbuffer=l,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].tbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(r),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);const c=t.gl.createBuffer();if(null===c)throw"Couldn't create buffer";this.bufferList[t.id].wvbuffer=c,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].wvbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(s),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);const d=t.gl.createBuffer();if(null===d)throw"Couldn't create buffer";this.bufferList[t.id].wnbuffer=d,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].wnbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(o),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null);const f=t.gl.createBuffer();if(null===f)throw"Couldn't create buffer";this.bufferList[t.id].wtbuffer=f,t.gl.bindBuffer(t.gl.ARRAY_BUFFER,this.bufferList[t.id].wtbuffer),t.gl.bufferData(t.gl.ARRAY_BUFFER,new Float32Array(a),t.gl.STATIC_DRAW),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),this.bufferList[t.id].geometryNeedUpdate=!1}updateMaterial(t){this.material.initProgram(t),this.bufferList[t.id].materialNeedUpdate=!1}display(t,e,i,r,s,o,a){if(!this.visible)return;this.matricesNeedUpdate&&this.updateMatrices(),(void 0===this.bufferList[t.id]||this.bufferList[t.id].geometryNeedUpdate)&&this.genBuffers(t);const n={uMMatrix:this.uMMatrix,uVMatrix:e,uPMatrix:i,uVInvMatrix:r,uNormalMatrix:this.uNormalMatrix,pointLights:s,spotLights:o,ambientLight:a};this.material.setUniforms(t,n),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wvbuffer:this.bufferList[t.id].vbuffer),t.gl.vertexAttribPointer(0,3,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wnbuffer:this.bufferList[t.id].nbuffer),t.gl.vertexAttribPointer(1,3,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,t.getMode()==t.gl.LINES?this.bufferList[t.id].wtbuffer:this.bufferList[t.id].tbuffer),t.gl.vertexAttribPointer(2,2,t.gl.FLOAT,!1,0,0),t.gl.bindBuffer(t.gl.ARRAY_BUFFER,null),this.material.hasTexture&&this.material.texture.bind(t),t.gl.drawArrays(t.getMode(),0,(t.getMode()==t.gl.LINES?2:1)*this.geometry.faces.length*3),this.material.hasTexture&&this.material.texture.unbind(t)}static loadObj(t,e){const i=new h(void 0,e),r=[];return t.split("\n").forEach(t=>{let e=t.replace(/\s+/g," ").trim().split(" ");"v"==e[0]?i.geometry.addVertex(new BABYLON.Vector3(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]))):"f"==e[0]&&r.push({v1:parseInt(e[1])-1,v2:parseInt(e[2])-1,v3:parseInt(e[3])-1})}),r.forEach(t=>i.geometry.addFace(t.v1,t.v2,t.v3)),i.requestGeometryUpdate(!0),i}static loadObjAsync(t,e){return i=this,r=void 0,o=function*(){const i=new h(void 0,e),r=[];return t.split("\n").forEach(t=>{const e=t.replace(/\s+/g," ").trim().split(" ");"v"==e[0]?i.geometry.addVertex(new BABYLON.Vector3(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]))):"f"==e[0]&&r.push({v1:parseInt(e[1])-1,v2:parseInt(e[2])-1,v3:parseInt(e[3])-1})}),r.forEach(t=>i.geometry.addFace(t.v1,t.v2,t.v3)),i.requestGeometryUpdate(!0),i},new((s=void 0)||(s=Promise))(function(t,e){function a(t){try{h(o.next(t))}catch(t){e(t)}}function n(t){try{h(o.throw(t))}catch(t){e(t)}}function h(e){e.done?t(e.value):new s(function(t){t(e.value)}).then(a,n)}h((o=o.apply(i,r)).next())});var i,r,s,o}}class l extends t{constructor(t,e,i){super();const r=void 0!==e,s=void 0!==i,o={width:10,height:10,depth:10};void 0!==t&&(o.width=t,s||r||(o.height=t,o.depth=t)),r&&(o.height=e),s&&(o.depth=i),this.addVertex(new BABYLON.Vector3(o.width,o.height,o.depth)),this.addVertex(new BABYLON.Vector3(-o.width,o.height,o.depth)),this.addVertex(new BABYLON.Vector3(o.width,-o.height,o.depth)),this.addVertex(new BABYLON.Vector3(-o.width,-o.height,o.depth)),this.addVertex(new BABYLON.Vector3(o.width,o.height,-o.depth)),this.addVertex(new BABYLON.Vector3(-o.width,o.height,-o.depth)),this.addVertex(new BABYLON.Vector3(o.width,-o.height,-o.depth)),this.addVertex(new BABYLON.Vector3(-o.width,-o.height,-o.depth)),this.addFace(0,1,2,BABYLON.Vector3.Forward(),new BABYLON.Vector2(1,1),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(3,1,2,BABYLON.Vector3.Forward(),new BABYLON.Vector2(0,0),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(4,5,6,new BABYLON.Vector3(0,0,-1),new BABYLON.Vector2(1,1),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(7,5,6,new BABYLON.Vector3(0,0,-1),new BABYLON.Vector2(0,0),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(0,1,4,BABYLON.Vector3.Up(),new BABYLON.Vector2(1,1),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(5,1,4,BABYLON.Vector3.Up(),new BABYLON.Vector2(0,0),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(2,3,6,new BABYLON.Vector3(0,-1,0),new BABYLON.Vector2(1,1),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(7,3,6,new BABYLON.Vector3(0,-1,0),new BABYLON.Vector2(0,0),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(0,2,4,BABYLON.Vector3.Right(),new BABYLON.Vector2(1,1),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(6,2,4,BABYLON.Vector3.Right(),new BABYLON.Vector2(0,0),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(1,3,5,BABYLON.Vector3.Left(),new BABYLON.Vector2(1,1),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0)),this.addFace(7,3,5,BABYLON.Vector3.Left(),new BABYLON.Vector2(0,0),new BABYLON.Vector2(0,1),new BABYLON.Vector2(1,0))}}const c=document.getElementsByTagName("canvas")[0];c.width=c.clientWidth,c.height=c.clientHeight;const d=new class{constructor(t,e){this.id=`renderer${(new Date).valueOf().toString()}`,this.canvas=t;let i=this.canvas.getContext("webgl",e);if(null==i)throw"WebGL not supported !";this.gl=i,this.gl.clearDepth(1),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.DEPTH_TEST),this.gl.clearColor(0,0,0,1),this.gl.enableVertexAttribArray(0),this.gl.enableVertexAttribArray(1),this.gl.enableVertexAttribArray(2),this.gl.activeTexture(this.gl.TEXTURE0),this.modes=[this.gl.TRIANGLES,this.gl.LINES,this.gl.POINTS],this.mode=0,this.programs={}}setMode(t){this.mode=t%3}getModeIdx(){return this.mode}getMode(){return this.modes[this.mode]}render(t,e,i){i&&i.bindFramebuffer(this),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),t.render(this,e),i&&i.unbindFramebuffer(this)}}(c),f=new class{get pos(){return this._pos}set pos(t){this._pos=t,this.matricesNeedUpdate=!0}get target(){return this._target}set target(t){this._target=t,this.matricesNeedUpdate=!0}get fov(){return this._fov}set fov(t){this._fov=t,this.matricesNeedUpdate=!0}get aspectRatio(){return this._aspectRatio}set aspectRatio(t){this._aspectRatio=t,this.matricesNeedUpdate=!0}get near(){return this._near}set near(t){this._near=t,this.matricesNeedUpdate=!0}get far(){return this._far}set far(t){this._far=t,this.matricesNeedUpdate=!0}get matricesNeedUpdate(){return this._matricesNeedUpdate||!this.cached.pos.equals(this.pos)||!this.cached.target.equals(this.target)}set matricesNeedUpdate(t){this._matricesNeedUpdate=t}constructor(t={pos:new BABYLON.Vector3(0,0,0),target:new BABYLON.Vector3(0,0,0),fov:45,aspectRatio:16/9,near:.1,far:1e4}){this.pos=void 0!==t.pos?t.pos:new BABYLON.Vector3(0,0,0),this.target=void 0!==t.target?t.target:new BABYLON.Vector3(0,0,0),this.cached={pos:this.pos,target:this.target},this.fov=void 0!==t.fov?t.fov:45,this.aspectRatio=void 0!==t.aspectRatio?t.aspectRatio:16/9,this.near=void 0!==t.near?t.near:.1,this.far=void 0!==t.far?t.far:1e4,this.matricesNeedUpdate=!0}updateMatrices(){this.cached.pos=this.pos.clone(),this.cached.target=this.target.clone(),this.uVMatrix=BABYLON.Matrix.LookAtRH(this.pos,this.target,BABYLON.Vector3.Up()),this.uPMatrix=BABYLON.Matrix.PerspectiveFovRH(this.fov,this.aspectRatio,this.near,this.far),this.uVInvMatrix=BABYLON.Matrix.Invert(this.uVMatrix),this.matricesNeedUpdate=!1}setDirection(t){this.target=this.pos.add(t)}lookAt(t){this.target=t}setPosition(t){this.pos=t}}({aspectRatio:d.canvas.width/d.canvas.height,pos:new BABYLON.Vector3(100,100,100)}),u=new class{constructor(){this.meshes=[],this.sortedMeshes={},this.pointLights=[],this.spotLights=[],this.ambientLight={color:BABYLON.Vector4.Zero()}}addMesh(t){return this.meshes.push(t),void 0===this.sortedMeshes[t.material.identifier]&&(this.sortedMeshes[t.material.identifier]=[]),this.sortedMeshes[t.material.identifier].push(t),t}getMesh(t){return this.meshes[t]}removeMesh(t){const e=this.meshes.splice(t,1)[0],i=this.sortedMeshes[e.material.identifier].indexOf(e);return this.sortedMeshes[e.material.identifier].splice(i,1),e}addPointLight(t,e=new BABYLON.Vector4(1,1,1,1),i=300){const r={pos:new BABYLON.Vector3(t.x,t.y,t.z),color:e,intensity:i};return this.pointLights.push(r),r}getPointLight(t){return this.pointLights[t]}removePointLight(t){return this.pointLights.splice(t,1)[0]}addSpotLight(t,e,i,r=new BABYLON.Vector4(1,1,1,1),s=300){const o={pos:new BABYLON.Vector3(t.x,t.y,t.z),dir:new BABYLON.Vector3(e.x,e.y,e.z),aperture:i,color:r,intensity:s,lookAt:function(t){let e=t.subtract(this.pos);this.dir.x=e.x,this.dir.y=e.y,this.dir.z=e.z}};return this.spotLights.push(o),o}getSpotLight(t){return this.spotLights[t]}removeSpotLight(t){return this.spotLights.splice(t,1)[0]}addAmbientLight(t){return this.ambientLight={color:t},this.ambientLight}removeAmbientLight(){let t=this.ambientLight.color;return this.ambientLight={color:BABYLON.Vector4.Zero()},t}render(t,e){e.matricesNeedUpdate&&e.updateMatrices();for(const i in this.sortedMeshes)void 0===t.programs[i]&&this.sortedMeshes[i][0].material.initProgram(t),t.programs[i].bind(t),this.sortedMeshes[i].forEach(i=>i.display(t,e.uVMatrix,e.uPMatrix,e.uVInvMatrix,this.pointLights,this.spotLights,this.ambientLight)),t.programs[i].unbind(t)}},g=new n({color:BABYLON.Vector4.One(),diffuse:1,specular:1,shininess:10});let m=0;const p=20,B=p/2,L=100/(2*p),A=[];for(let t=-B;t<B;t++){A.push([]);for(let e=-B;e<B;e++){const i=new h(new l(L,20,L),g);i.pos.x=e*(L+2),i.pos.z=t*(L+2),A[t+B].push(i),u.addMesh(i)}}u.addPointLight(new BABYLON.Vector3(0,1e3,0),void 0,1e3),u.addPointLight(new BABYLON.Vector3(1e3,1e3,0),void 0,1e3),console.log(u);setInterval(()=>(function(){for(let t=0;t<p;t++)for(let e=0;e<p;e++){const s=A[t][e],o=i(Math.sin(m-i(r(t,e,B,B),0,B,-Math.PI,Math.PI)),-1,1,10,100);s.geometry.vertices.forEach(t=>{t.pos.y<0?t.pos.y=-o/2:t.pos.y=o/2}),s.requestGeometryUpdate(!0)}m+=.15})(),10);let v=!1;const N={distance:100,mode:0};function x(t){f.pos=new BABYLON.Vector3(t,t,t)}document.addEventListener("contextmenu",t=>t.preventDefault()),document.addEventListener("wheel",t=>{N.distance-=t.deltaY>0?-10:10,x(N.distance)}),document.addEventListener("keypress",t=>{"w"==t.key?d.setMode(d.getModeIdx()+1):"e"==t.key&&(v=!v)});const b=new dat.GUI({autoPlace:!0,name:"Scene control"}).addFolder("Scene");b.add(N,"distance",0,750).onChange(t=>{x(t),N.distance=t,console.log(N.distance)});b.add(N,"mode",{Standard:0,Wireframe:1,Points:2}).onChange(t=>{d.setMode(N.mode),N.mode=d.getModeIdx()}),function t(){v&&A.forEach(t=>t.forEach(t=>t.rotate(.02,.02,.02))),d.render(u,f),requestAnimationFrame(t)}()}();
